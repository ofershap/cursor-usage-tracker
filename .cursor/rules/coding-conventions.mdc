---
description: Coding conventions and patterns for cursor-usage-tracker
globs: "**/*.{ts,tsx}"
alwaysApply: false
---

# Coding Conventions

## Imports

- NO `.js` extensions on internal imports — Next.js Turbopack bundler resolution doesn't support them
- Use `@/` path alias for imports from `src/` (configured in tsconfig.json)
- Use `import type` for type-only imports

```typescript
import { getDb } from "@/lib/db";
import type { Anomaly } from "@/lib/types";
```

## Database

- All DB access goes through `src/lib/db.ts` — never import better-sqlite3 directly in pages/routes
- Use `getDb()` singleton — it initializes schema on first call
- Use transactions for batch inserts: `db.transaction(() => { ... })()`
- SQLite column names use snake_case; TypeScript types use camelCase
- Key-value metadata stored in `metadata` table via `setMetadata()`/`getMetadata()`

## API Routes

- All API routes use `export const dynamic = "force-dynamic"` (data is always fresh from SQLite)
- Cron endpoint requires `x-cron-secret` header or `?secret=` query param
- Use Next.js App Router async params pattern: `{ params }: { params: Promise<{ id: string }> }`
- Most GET endpoints support `?days=N` query param for time range filtering

## Components

- Dashboard pages: server component (page.tsx) fetches data, passes to client component (*-client.tsx)
- Charts are always client components ("use client")
- Use Tailwind CSS with zinc color palette (dark theme)
- No shadcn/ui installed — components are hand-rolled
- Model names displayed via `shortModel()` from `src/lib/format-utils.ts` with full name in tooltip
- Self-contained components: components like `upgrade-banner.tsx` are designed with minimal footprint — single file, own modal/overlay logic baked in, easy to add/remove with 1-2 line diffs in consuming files. Do NOT extract shared modals or abstractions from them; keep them isolated.
- `ExpandableCard` (`src/components/expandable-card.tsx`): wraps any card to add a fullscreen expand button. Wrap the outer card div, don't restructure the card internals.

## Anomaly Detection

- Three layers: thresholds → zscore → trends (all in `src/lib/anomaly/`)
- `detector.ts` orchestrates all three, deduplicates by `userEmail:type:metric` key
- New anomalies get inserted; existing ones that no longer fire get auto-resolved
- Run via `npm run detect` CLI or as part of `POST /api/cron`

## Testing

- Tests in `tests/` directory, use Vitest
- Anomaly tests create their own test SQLite DB (not the main db.ts singleton)
- API client tests mock `globalThis.fetch`
